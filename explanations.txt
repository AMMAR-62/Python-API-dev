needs of virtual environments?
project 1 -> fast api v1.2.1
new project 2 -> fast api v2.4.3
upgrade fast api
this may be a problem, if the fast api version is not compatible with other project
the projects need different versions
isolated environments, virtual environments.

==============================================

interpreter in the virtual environment needs to be used so we change the interpreter

==============================================
why we need a schema:
 - it's a pain to get all the values from the body.
 - the client can send whatever data they want.
 - the data isn't getting validated.
 - we ultimately want to force the client to send data in a schema that we expect.
 - the pydantic is used for defining the schema.
 - we use the pydantic models which are the similar to the mongoose models in the MERN stack.
 - pydantic models can be converted to the dictionary by using the .dict() method.

==============================================
CRUD - create, read, update, delete - four main functions of the api.
create - post.
read - get
update - put/patch
delete - delete

 - we always use the plurals, it's the convention.
 - like /posts, /posts/:id, /posts, etc.
 - we use the curly braces for the argument like {id}
 - patch - for specific field.
 - put - all of the same information, and change the field we need.

===============================================
we refractor the code as:
 - the fast api provides in built support for the documentation.
 - it is powered by swagger ui.
 - for any folder to act as a package python requires you to store the __init__.py file in it.
what is a database:
 - Collection of organised data that can be easily accessed and managed.
 - we don't work or interact with database directly.
 - instead we make use of a software referred to as a database management system.
 - relational - mysql, postgresql, oracle, sql server.
 - nosql - mongodb, dynamodb, oracle, sql server.
relational database and sql:
 - structured query language - languase used to communicate with the database.
 - each instance of postgres can be carved into multiple separate databases.
 - by default every postgres, installation comes with one database already created called postgres.
 - this is important because postgres requires you to specify the name of a database to make a connection, so there needs to be always be one database.
tables:
 - a table represents a subject or event in an application.
 - users, products, purchases, can be tables of an e-commerce application.
columns and rows:
 - a table is made up of columns and rows.
 - each column represents a different attribute.
 - each row represents a different entry in the table.
postgres datatype:
 - database have datatypes just like any programming language.
 - postgres -> numeric (int, decimal, precision), text(varchar, text), bool(boolean), sequence(array)
primary key:
 - is a column or group of column that uniquely identifies each row in a table.
 - table can have one and only one primary key.
 - each entry must be unique, no duplicates.
 - the primary key does not have to be the ID column always. It's up to you to decide which column uniquely defines each record.
 - in this example, since an email can only be registered once, the email column can also be used as the primary key.
unique constraints:
 - a unique constraint can be applied to any column to make sure every record has a unique value for that column.
null constraints:
 - by default, when adding a new entry to a database, any column can be left blank, when a column is left blank, it has a null value.
 - if you need column to be properly filled in to create a new record, a NOT NULL constraint can be added to the column to ensure that the column is never left blank.
 - creating the database.
CREATE DATABASE fastapi
    WITH 
    OWNER = postgres
    ENCODING = 'UTF8'
    CONNECTION LIMIT = -1;
-- SELECT * FROM products;
-- SELECT name FROM products;
-- SELECT name, id, price FROM products;
-- SELECT id as product_id FROM products;
-- SELECT * FROM products WHERE id=12;
-- SELECT * FROM products WHERE inventory = 0;
-- SELECT * FROM products WHERE name = 'Laptop';
-- SELECT * FROM products WHERE price>5000;
-- SELECT * FROM products WHERE price<5000;
-- SELECT * FROM products WHERE inventory<>0;
-- SELECT * FROM products WHERE inventory>0 AND price>4000;
-- SELECT * FROM products WHERE id = 1 or id=2 or id=3;
-- SELECT * FROM products WHERE id IN (1,2,3);
-- SELECT * FROM products ORDER BY price;
-- SELECT * FROM products ORDER BY inventory DESC, price ASC;
-- SELECT * FROM products ORDER BY created_at DESC;
-- SELECT * FROM products WHERE price>5000 ORDER BY price;
-- SELECT * FROM products WHERE price>10 LIMIT 5;
-- SELECT * FROM products ORDER BY id LIMIT 5;
-- SELECT * FROM products ORDER BY id LIMIT 5 OFFSET 2;
-- INSERT INTO products (name, price, inventory) VALUES ('tortilla', 4, 1000);
-- INSERT INTO products (price, name, inventory) VALUES (5000,'Showcase' , 1000);
-- INSERT INTO products (price, name, inventory) VALUES (30000,'Computer' , 1000) returning *;
-- INSERT INTO products (price, name, inventory) VALUES (7000,'Water Filter', 1000), (8000, 'Wooden Almirah', 1) returning *;
-- DELETE FROM products WHERE Id =11;
-- DELETE FROM products WHERE id = 12 RETURNING *;
-- DELETE FROM products WHERE inventory=0 RETURNING *;
-- UPDATE products SET name='Electronic Filter', price=15000 WHERE id=25;
-- UPDATE products SET name='Eletric Car', price=3000000 WHERE name='Car' RETURNING *;

===============================================
OBJECT RELATIONAL MODEL:
 -  Layer of abstraction that sits between the database and use.
 - We can perform all database operations through traditional python code. No more SQL!
 - instead of using raw sql, we use the raw python code.
WHAT CAN ORMs DO:
 - Instead of manually defining tables in postgres, we can define our tables as python models.
  - Queries can be made exclusively through python code. No SQL is necessary.
SQLALCHEMY:
- SqlAlchemy is one of the most popular python ORMs.
 - It is a standalone library and has no association with FastAPI. It can be use with any other python web frameworks or any python based application.
however sqlalchemy is not sufficient for modifying the tables and things like that.
 - we can use the alembic software for more support.

Schema Models vs. ORM Models:
 - Schema/Pydantic Models define the structure of a request and response.
 - This ensure that when a user wants to create a post, the request will only go through if it has a "title" and "content" in the body.
SQLALCHEMY MODELS:
 - responsible for defining the columns of our "posts" table within postgres.
 - is used to query, create, delete and update entries within the database.

===============================================
JWT Token Authentication:
 - Client, API: two main ways, session based authentication, to track whether a user is logged, and when the user is logged out.
 - it's stateless, there is nothing on the database, nothing on the api, etc, we do not store, it's stored on the frontend.
 - if the credentials match up, then we make the jwt token, the client doesn't know and doesn't cares about the tokens.
 - api is going to find that if it's a valid token, you provide the authentication, provide the token.
 - components of a tokens are: - it's not encrypted, header (includes metadata about the token), payload (is upto us, we can send anything that we want, the token itself is not encrypted, we don't put any password or secrets in the payload), signature (contains the combination of header, payload and token secret, we use the signature to know that this is the user)
 -   